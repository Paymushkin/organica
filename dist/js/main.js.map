{"version":3,"sources":["main.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourcesContent":["// Главный JavaScript файл\n\n// Инициализация при загрузке DOM\ndocument.addEventListener('DOMContentLoaded', function() {\n  console.log('Сайт загружен');\n  \n  // Инициализация компонентов\n  initMobileMenu();\n  initMobileMenuBar();\n  initSmoothScroll();\n  initLazyLoading();\n  initTabs();\n  initHeaderScrollFill();\n  initModals();\n  initFaqDetailsAnimation();\n});\n\n// Мобильное меню (полноэкранное)\nfunction initMobileMenu() {\n  const burger = document.querySelector('.header__burger');\n  const menuBarButton = document.querySelector('.mobile-menu-bar__button');\n  const mobileMenu = document.querySelector('.mobile-menu');\n  const mobileMenuClose = document.querySelector('.mobile-menu__close');\n  const header = document.querySelector('.header');\n  const body = document.body;\n\n  if (!mobileMenu) return;\n\n  const openMenu = () => {\n    mobileMenu.classList.add('mobile-menu--open');\n    // Скрываем header при открытии меню\n    if (header) {\n      header.style.display = 'none';\n    }\n    // Блокируем прокрутку body\n    body.style.overflow = 'hidden';\n  };\n\n  const closeMenu = () => {\n    mobileMenu.classList.remove('mobile-menu--open');\n    // Показываем header при закрытии меню\n    if (header) {\n      header.style.display = '';\n    }\n    // Разблокируем прокрутку body\n    body.style.overflow = '';\n  };\n\n  const toggleMenu = () => {\n    const isOpen = mobileMenu.classList.contains('mobile-menu--open');\n    if (isOpen) {\n      closeMenu();\n    } else {\n      openMenu();\n    }\n  };\n\n  // Обработчики открытия\n  if (burger) {\n    burger.addEventListener('click', (e) => {\n      e.stopPropagation();\n      toggleMenu();\n    });\n  }\n\n  if (menuBarButton) {\n    menuBarButton.addEventListener('click', (e) => {\n      e.stopPropagation();\n      toggleMenu();\n    });\n  }\n\n  // Обработчик закрытия\n  if (mobileMenuClose) {\n    mobileMenuClose.addEventListener('click', (e) => {\n      e.stopPropagation();\n      closeMenu();\n    });\n  }\n\n  // Закрытие при клике на backdrop\n  const backdrop = document.querySelector('.mobile-menu__backdrop');\n  if (backdrop) {\n    backdrop.addEventListener('click', (e) => {\n      if (e.target === backdrop) {\n        closeMenu();\n      }\n    });\n  }\n\n  // Закрытие при нажатии Escape\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape' && mobileMenu.classList.contains('mobile-menu--open')) {\n      closeMenu();\n    }\n  });\n}\n\n// Попапы (универсальная инициализация)\nfunction initModals() {\n  const body = document.body;\n\n  function openModal(name) {\n    const modal = document.querySelector(`[data-modal=\"${name}\"]`);\n    if (!modal) return;\n    \n    // Закрываем мобильное меню, если оно открыто\n    const mobileMenu = document.querySelector('.mobile-menu');\n    if (mobileMenu && mobileMenu.classList.contains('mobile-menu--open')) {\n      mobileMenu.classList.remove('mobile-menu--open');\n      const header = document.querySelector('.header');\n      if (header) {\n        header.style.display = '';\n      }\n    }\n    \n    modal.classList.add('is-open');\n    modal.setAttribute('aria-hidden', 'false');\n    body.style.overflow = 'hidden';\n    \n    // Сбрасываем класс валидации при открытии попапа\n    const form = modal.querySelector('.modal-form');\n    if (form) {\n      form.classList.remove('was-validated');\n    }\n  }\n\n  function closeModal(modal) {\n    if (!modal) return;\n    modal.classList.remove('is-open');\n    modal.setAttribute('aria-hidden', 'true');\n    body.style.overflow = '';\n  }\n\n  // Открытие по клику на любой триггер\n  document.addEventListener('click', (e) => {\n    const trigger = e.target.closest('[data-modal-open]');\n    if (trigger) {\n      const name = trigger.getAttribute('data-modal-open');\n      if (name) {\n        e.preventDefault();\n        openModal(name);\n      }\n    }\n\n    // Закрытие по кнопке или клику на затемнение\n    const closeBtn = e.target.closest('[data-modal-close]');\n    if (closeBtn) {\n      const modal = e.target.closest('.modal') || document.querySelector('.modal.is-open');\n      if (modal) closeModal(modal);\n    }\n  });\n\n  // Закрытие по ESC\n  document.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      const opened = document.querySelector('.modal.is-open');\n      if (opened) closeModal(opened);\n    }\n  });\n\n  // Обработка отправки формы (в попапе и на странице)\n  document.addEventListener('submit', (e) => {\n    const modalForm = e.target.closest('.modal-form');\n    const pageForm = e.target.closest('.request-form');\n    const form = modalForm || pageForm;\n    \n    if (!form) return;\n\n    e.preventDefault();\n\n    // Добавляем класс для показа ошибок валидации\n    form.classList.add('was-validated');\n\n    // Проверка валидности формы\n    if (!form.checkValidity()) {\n      form.reportValidity();\n      return;\n    }\n\n    // Здесь можно добавить отправку данных через AJAX\n    // Например:\n    // const formData = new FormData(form);\n    // fetch('/api/submit', { method: 'POST', body: formData })\n    //   .then(response => response.json())\n    //   .then(data => { ... })\n    //   .catch(error => { ... });\n\n    // Временная заглушка: просто выводим сообщение\n    console.log('Форма отправлена:', new FormData(form));\n    \n    // Можно показать сообщение об успехе\n    // alert('Заявка успешно отправлена!');\n    \n    // Сбрасываем класс валидации и форму\n    form.classList.remove('was-validated');\n    form.reset();\n  });\n\n  // Убираем красную обводку при изменении чекбокса\n  document.addEventListener('change', (e) => {\n    const checkbox = e.target;\n    if (checkbox.type === 'checkbox') {\n      const modalForm = checkbox.closest('.modal-form');\n      const pageForm = checkbox.closest('.request-form');\n      const form = modalForm || pageForm;\n      \n      if (form && checkbox.checked && form.classList.contains('was-validated')) {\n        // Если чекбокс отмечен, проверяем всю форму\n        if (form.checkValidity()) {\n          form.classList.remove('was-validated');\n        }\n      }\n    }\n  });\n}\n\n\n// Табы (переиспользуемая инициализация)\nfunction initTabs() {\n  const containers = document.querySelectorAll('[data-tabs]');\n  containers.forEach(container => {\n    const tabs = container.querySelectorAll('.tabs__tab');\n    const panels = container.querySelectorAll('.tabs__panel');\n\n    tabs.forEach(tab => {\n      tab.addEventListener('click', () => {\n        const target = tab.getAttribute('data-tab');\n        // Активное состояние на кнопках\n        tabs.forEach(t => t.classList.toggle('is-active', t === tab));\n        // Переключение панелей\n        panels.forEach(panel => {\n          panel.classList.toggle('is-active', panel.getAttribute('data-tab-panel') === target);\n        });\n        const targetPanel = container.querySelector(`.tabs__panel[data-tab-panel=\"${target}\"]`);\n        // Переинициализация слайдеров новостей при переключении таба\n        if (window.newsSlidersRefresh) {\n          // Перестраиваем все слайдеры и дополнительно обновляем те, что в целевой панели\n          setTimeout(() => {\n            window.newsSlidersRefresh();\n            if (targetPanel) {\n              const swipers = targetPanel.querySelectorAll('.news__slider .swiper');\n              swipers.forEach(swiperEl => {\n                const inst = window.newsSwiperInstances && window.newsSwiperInstances.get(swiperEl);\n                if (inst) {\n                  inst.update();\n                  inst.updateAutoHeight(200);\n                }\n              });\n              // Дополнительно стабилизируем высоту после обновления\n              requestAnimationFrame(() => {\n                swipers.forEach(swiperEl => {\n                  const inst = window.newsSwiperInstances && window.newsSwiperInstances.get(swiperEl);\n                  if (inst) {\n                    inst.updateAutoHeight(200);\n                  }\n                });\n              });\n            }\n          }, 100);\n        }\n      });\n    });\n  });\n}\n\n// Плавная прокрутка\nfunction initSmoothScroll() {\n  const links = document.querySelectorAll('a[href^=\"#\"]');\n  \n  links.forEach(link => {\n    link.addEventListener('click', function(e) {\n      e.preventDefault();\n      \n      const targetId = this.getAttribute('href').substring(1);\n      const targetElement = document.getElementById(targetId);\n      \n      if (targetElement) {\n        targetElement.scrollIntoView({\n          behavior: 'smooth',\n          block: 'start'\n        });\n      }\n    });\n  });\n}\n\n// Ленивая загрузка изображений\nfunction initLazyLoading() {\n  const images = document.querySelectorAll('img[data-src]');\n  \n  if ('IntersectionObserver' in window) {\n    const imageObserver = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting) {\n          const img = entry.target;\n          img.src = img.dataset.src;\n          img.classList.remove('lazy');\n          imageObserver.unobserve(img);\n        }\n      });\n    });\n    \n    images.forEach(img => imageObserver.observe(img));\n  } else {\n    // Fallback для старых браузеров\n    images.forEach(img => {\n      img.src = img.dataset.src;\n    });\n  }\n}\n\n// Белая заливка header при скролле\nfunction initHeaderScrollFill() {\n  const header = document.querySelector('.header');\n  if (!header) return;\n\n  let ticking = false;\n\n  const updateHeader = () => {\n    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;\n    \n    if (scrollY >= 20) {\n      header.classList.add('header--scrolled');\n    } else {\n      header.classList.remove('header--scrolled');\n    }\n    \n    ticking = false;\n  };\n\n  const onScroll = () => {\n    if (!ticking) {\n      window.requestAnimationFrame(updateHeader);\n      ticking = true;\n    }\n  };\n\n  // Первичная установка\n  updateHeader();\n\n  // Слушатель скролла с оптимизацией через requestAnimationFrame\n  window.addEventListener('scroll', onScroll, { passive: true });\n}\n\n// Плашка меню для мобильной версии (появляется при скролле)\nfunction initMobileMenuBar() {\n  const menuBar = document.querySelector('.mobile-menu-bar');\n  if (!menuBar) return;\n\n  // Только на мобильных устройствах\n  if (window.innerWidth > 767) return;\n\n  const updateVisibility = () => {\n    // Получаем значение скролла из нескольких источников для совместимости\n    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;\n    \n    // При скролле меньше 50px (включая 0) - плашка скрыта\n    // Используем строгое сравнение для гарантированного скрытия при нулевом скролле\n    if (scrollY < 50) {\n      menuBar.classList.remove('mobile-menu-bar--visible');\n    } else {\n      // При скролле >= 50px - показываем плашку\n      menuBar.classList.add('mobile-menu-bar--visible');\n    }\n  };\n\n  // Дополнительная проверка при достижении верха страницы\n  const checkScrollTop = () => {\n    const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop || 0;\n    if (scrollY === 0) {\n      menuBar.classList.remove('mobile-menu-bar--visible');\n    }\n  };\n\n  // Первичная установка\n  updateVisibility();\n\n  // Слушатели с более частой проверкой для надежности\n  window.addEventListener('scroll', () => {\n    updateVisibility();\n    // Дополнительная проверка при достижении верха\n    checkScrollTop();\n  }, { passive: true });\n\n  window.addEventListener('scrollend', checkScrollTop, { passive: true });\n\n  window.addEventListener('resize', utils.debounce(() => {\n    if (window.innerWidth > 767) {\n      menuBar.classList.remove('mobile-menu-bar--visible');\n    } else {\n      updateVisibility();\n    }\n  }, 150));\n}\n\n// Плавная анимация открытия/закрытия для details в секции FAQ\nfunction initFaqDetailsAnimation() {\n  const detailsList = document.querySelectorAll('.faq details');\n  if (!detailsList.length) return;\n\n  detailsList.forEach((det) => {\n    const summary = det.querySelector('summary');\n    const answer = det.querySelector('.faq__answer');\n    if (!summary || !answer) return;\n\n    // Инициализация исходного состояния\n    if (det.open) {\n      answer.style.maxHeight = answer.scrollHeight + 'px';\n      answer.style.opacity = '1';\n    } else {\n      answer.style.maxHeight = '0px';\n      answer.style.opacity = '0';\n    }\n\n    summary.addEventListener('click', (e) => {\n      e.preventDefault();\n\n      // Закрытие\n      if (det.open) {\n        // фиксируем текущую высоту, затем анимируем к 0\n        answer.style.maxHeight = answer.scrollHeight + 'px';\n        answer.style.opacity = '1';\n        requestAnimationFrame(() => {\n          answer.style.maxHeight = '0px';\n          answer.style.opacity = '0';\n        });\n        const onCloseEnd = (ev) => {\n          if (ev.propertyName !== 'max-height') return;\n          answer.removeEventListener('transitionend', onCloseEnd);\n          det.open = false;\n        };\n        answer.addEventListener('transitionend', onCloseEnd);\n      } else {\n        // Открытие\n        det.open = true;\n        // старт с 0 к нужной высоте\n        answer.style.maxHeight = '0px';\n        answer.style.opacity = '0';\n        requestAnimationFrame(() => {\n          answer.style.maxHeight = answer.scrollHeight + 'px';\n          answer.style.opacity = '1';\n        });\n        const onOpenEnd = (ev) => {\n          if (ev.propertyName !== 'max-height') return;\n          answer.removeEventListener('transitionend', onOpenEnd);\n          // опционально снять максимум, чтобы контент с динамической высотой не обрезался после открытии\n          answer.style.maxHeight = answer.scrollHeight + 'px';\n        };\n        answer.addEventListener('transitionend', onOpenEnd);\n      }\n    });\n  });\n}\n\n// Утилиты\nconst utils = {\n  // Дебаунс функция\n  debounce: function(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  },\n  \n  // Троттлинг функция\n  throttle: function(func, limit) {\n    let inThrottle;\n    return function() {\n      const args = arguments;\n      const context = this;\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n};\n\n"]}